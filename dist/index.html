<!DOCTYPE html>
<html lang="en">

<head>
  <title>TunnlTo - Home</title>
  <meta charset="UTF-8">
  <script type="module">
    import Tunnel from './js/tunnel.js'
    import { showToast, closeToast } from './js/globals.js'

    const { invoke } = window.__TAURI__.tauri
    const localStorageData = { ...localStorage }

    let tunnelSelectElement
    let enableButtonElement
    let editButtonElement
    let tunnelOptionsElement
    let toastElement
    let toastCloseButtonElement
    let toastMessageElement

    // Wait for DOM content to load
    window.addEventListener('DOMContentLoaded', () => {
      // Get elements
      tunnelSelectElement = document.getElementById('tunnelSelect')
      enableButtonElement = document.getElementById('enableButton')
      editButtonElement = document.getElementById('editButton')
      tunnelOptionsElement = document.getElementById('tunnelOptions')
      toastElement = document.getElementById('toast')
      toastCloseButtonElement = document.getElementById('toastCloseButton')
      toastMessageElement = document.getElementById('toastMessage')

      // Setup listeners on elements
      tunnelSelectElement.onchange = () => { saveSelectedTunnel() }
      enableButtonElement.onclick = () => { toggleTunnel() }
      editButtonElement.onclick = () => { editClick() }
      toastCloseButtonElement.onclick = () => { closeToast(toastElement) }
    })

    // Check if WireSock is installed
    console.log('Checking if WireSock is installed')
    if (!await isWiresockInstalled()) {
      // Not installed so take the user to the setup page
      window.location.href = 'setup.html'
    }

    // Make sure the WireSock service is not installed
    console.log('Checking if WireSock service is installed')
    if (await isWireSockServiceInstalled()) {
      // Service is installed so need to warn the user that it needs to be uninstalled or disabled
      showToast(toastElement, toastMessageElement, 'WireSock is currently installed in service mode. This may conflict with TunnlTo. </br></br>Please uninstall WireSock from your system and then restart TunnlTo.')
    }

    // Iterate through the localstorage keys to see if any tunnels are listed
    for (let x in localStorageData) {
      if (x.startsWith('tunnel-wireguard-')) {
        // Remove the descriptor prefix at the start of the string
        x = x.replace('tunnel-wireguard-', '')

        // Add the tunnel name as an option in the select dropdown
        const opt = document.createElement('option')
        opt.value = x
        opt.innerHTML = x
        tunnelSelectElement.appendChild(opt)

        // Show the tunnel options now that we have an option to display
        if (tunnelOptionsElement.classList.contains('hidden')) {
          tunnelOptionsElement.classList.remove('hidden')
        }
      }
    }

    // Set the selected tunnel based on local storage
    const selectedTunnel = getSelectedTunnel()
    if (selectedTunnel !== null) {
      setSelectedTunnel(selectedTunnel)
    }

    // Check to see if the WireSock process is already running
    console.log('Checking if WireSock is already running')
    if (await isWiresockRunning()) {
      // WireSock is already running. Update the UI
      tunnelEnabledUI()
    } else {
      tunnelDisabledUI()
    }

    // Navigate to the wireguard page
    function editClick () {
      // Name parameter is encoded in case it uses characters not allowed in URL parameters
      window.location.href = `wireguard.html?edit=true&name=${encodeURIComponent(getSelectedTunnel(), 'UTF-8')}`
    }

    // Save the value of the tunnel select to local storage
    function saveSelectedTunnel () {
      localStorage.setItem('selectedTunnel', tunnelSelectElement.value)
    }

    // Look up local storage for the currenctly selected tunnel
    function getSelectedTunnel () {
      return localStorage.getItem('selectedTunnel')
    }

    // Set the select element to the last selected tunnel
    function setSelectedTunnel () {
      tunnelSelectElement.value = getSelectedTunnel()
    }

    // Tell Rust to enable or disable the WireSock process
    async function toggleTunnel () {
      if (enableButtonElement.innerHTML === 'Enable') {
        // Enable the tunnel

        // Get the currently selected tunnel
        const name = getSelectedTunnel()

        // Get the tunnel data
        const data = JSON.parse(localStorage.getItem(`tunnel-wireguard-${name}`))
        const tunnel = Object.assign(new Tunnel(), data)

        // Send the message down to Tauri Rust function
        try {
          console.info(await invoke('enable_wiresock', {
            // Required parameters
            privateKey: tunnel.privateKey,
            interfaceAddress: tunnel.interfaceAddress,
            dns: tunnel.dns,
            publicKey: tunnel.publicKey,
            endpoint: tunnel.endpoint,
            // Optional parameters
            ...tunnel.presharedKey && { presharedKey: tunnel.presharedKey },
            ...tunnel.allowedApps && { allowedApps: tunnel.allowedApps },
            ...tunnel.disallowedApps && { disallowedApps: tunnel.disallowedApps },
            ...tunnel.allowedIPs && { allowedIPs: tunnel.allowedIPs },
            ...tunnel.disallowedIPs && { disallowedIPs: tunnel.disallowedIPs },
            ...tunnel.mtu && { mtu: tunnel.mtu }
          }))
        } catch (error) {
          console.error(`Invoking enable_wiresock returned error: ${error}`)
          // Show the error to the user
          return showToast(toastElement, toastMessageElement, `${error}`)
        }

        // Connection success so update the UI
        tunnelEnabledUI()
      } else {
        // Disable the tunnel

        try {
          await invoke('disable_wiresock')
        } catch (error) {
          console.error(`Invoking disable_wiresock returned error: ${error}`)
          return showToast(toastElement, toastMessageElement, `Error stopping WireSock process: ${error}`)
        }

        // Update the UI
        tunnelDisabledUI()
      }
    }

    // Set the UI to show the tunnel is enabled
    function tunnelEnabledUI () {
      enableButtonElement.classList.remove('button-green')
      enableButtonElement.classList.add('button-red')
      enableButtonElement.innerHTML = 'Disable'

      tunnelSelectElement.disabled = true

      editButtonElement.disabled = true
    }

    // Set the UI to show the tunnel is disabled
    function tunnelDisabledUI () {
      enableButtonElement.classList.remove('button-red')
      enableButtonElement.classList.add('button-green')
      enableButtonElement.innerHTML = 'Enable'

      tunnelSelectElement.disabled = false

      editButtonElement.disabled = false
    }

    // Tell Rust to check if the WireSock process is running
    async function isWiresockRunning () {
      try {
        const result = await invoke('check_wiresock_process')
        console.info(result)
        if (result === 'WIRESOCK_IS_RUNNING') {
          return true
        } else if (result === 'WIRESOCK_NOT_RUNNING') {
          return false
        } else {
          showToast(toastElement, toastMessageElement, `Error checking WireSock process: ${result}`)
          return false
        }
      } catch (error) {
        console.error(`Invoking check_wiresock_process returned error: ${error}`)
        // Show the error to the user
        return showToast(toastElement, toastMessageElement, error)
      }
    }

    // Tell Rust to check if WireSock is installed
    async function isWiresockInstalled () {
      try {
        const result = await invoke('check_wiresock_installed')
        console.info(result)
        if (result === 'WIRESOCK_INSTALLED') {
          return true
        } else if (result === 'WIRESOCK_NOT_INSTALLED') {
          return false
        } else {
          showToast(toastElement, toastMessageElement, `Error checking if WireSock installed: ${result}`)
          return false
        }
      } catch (error) {
        console.error(`Invoking check_wiresock_installed returned error: ${error}`)
        // Show the error to the user
        return showToast(toastElement, toastMessageElement, error)
      }
    }

    // Tell Rust to check if the WireSock service is installed
    async function isWireSockServiceInstalled () {
      try {
        const result = await invoke('check_wiresock_service')
        console.info(result)
        if (result === 'WIRESOCK_SERVICE_NOT_INSTALLED') {
          return false
        } else if (result === 'WIRESOCK_SERVICE_INSTALLED') {
          return true
        } else {
          showToast(toastElement, toastMessageElement, `Error checking if WireSock service is installed: ${result}`)
          return false
        }
      } catch (error) {
        console.error(`Invoking check_wiresock_service returned error: ${error}`)
        // Show the error to the user
        return showToast(toastElement, toastMessageElement, error)
      }
    }
  </script>
  <link rel="stylesheet" type="text/css" href="./css/globals.css">
</head>

<!-- body is hidden until light or dark mode is set -->

<body class="hidden">

  <!-- Using async makes the script run immediately as module is deferred by default -->
  <script type="module" async>
    import { setDarkMode } from './js/globals.js'

    // See if there is a dark mode setting saved in local storage
    if (!localStorage.getItem('darkMode')) {
      const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
      const lightModeMediaQuery = window.matchMedia('(prefers-color-scheme: light)')

      if (darkModeMediaQuery.matches) {
        localStorage.setItem('darkMode', true)
      } else if (lightModeMediaQuery.matches) {
        localStorage.setItem('darkMode', false)
      } else {
        localStorage.setItem('darkMode', false)
      }
    }

    // Set light or dark mode
    setDarkMode()
  </script>

  <main>
    <h1 class="container">TunnlTo</h1>
    <div id="tunnelOptions" class="container hidden">
      <select id="tunnelSelect"></select>
      <button id="enableButton">Enable</button>
      <button id="editButton">Edit</button>
    </div>
    <div class="container">
      <button id="addTunnelButton">Add Tunnel</button>
      <a href="settings.html"><button id="settingsButton">Settings</button></a>
    </div>
    <div class="toast" id="toast">
      <p id="toastMessage"><!-- innerHTML is dynamically added in Javascript --></p>
      <button id="toastCloseButton">&#10005;</button>
    </div>
  </main>

</body>

</html>