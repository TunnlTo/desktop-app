<!DOCTYPE html>
<html lang="en">

<head>
  <title>TunnlTo - Home</title>
  <meta charset="UTF-8">
  <script type="module">
    import Tunnel from './js/tunnel.js'
    import { showToast, closeToast } from './js/globals.js'

    const { invoke } = window.__TAURI__.tauri
    const localStorageData = { ...localStorage }

    let tunnelSelectElement
    let enableButtonElement
    let editButtonElement
    let tunnelOptionsElement
    let toastElement
    let toastCloseButtonElement
    let toastMessageElement
    let addTunnelButtonElement

    // Wait for DOM content to load
    window.addEventListener('DOMContentLoaded', () => {
      // Get elements
      tunnelSelectElement = document.getElementById('tunnelSelect')
      enableButtonElement = document.getElementById('enableButton')
      editButtonElement = document.getElementById('editButton')
      tunnelOptionsElement = document.getElementById('tunnelOptions')
      toastElement = document.getElementById('toast')
      toastCloseButtonElement = document.getElementById('toastCloseButton')
      toastMessageElement = document.getElementById('toastMessage')
      addTunnelButtonElement = document.getElementById('addTunnelButton')

      // Setup listeners on elements
      tunnelSelectElement.onchange = () => { saveSelectedTunnel() }
      enableButtonElement.onclick = () => { toggleTunnel() }
      editButtonElement.onclick = () => { editClick() }
      toastCloseButtonElement.onclick = () => { closeToast(toastElement) }
      addTunnelButtonElement.onclick = () => { addTunnelClick() }
    })

    // Check if WireSock is installed
    console.log('Checking if WireSock is installed')
    if (!await isWiresockInstalled()) {
      // Not installed so take the user to the setup page
      window.location.href = 'setup.html'
    }

    // Make sure the WireSock service is not installed
    console.log('Checking if WireSock service is installed')
    if (await isWireSockServiceInstalled()) {
      // Service is installed so need to warn the user that it needs to be uninstalled or disabled
      showToast(toastElement, toastMessageElement, 'WireSock is currently installed in service mode. This may conflict with TunnlTo. </br></br>Please uninstall WireSock from your system and then restart TunnlTo.')
    }

    // Iterate through the localstorage keys to see if any tunnels are listed
    for (let x in localStorageData) {
      if (x.startsWith('tunnel-wireguard-')) {
        // Remove the descriptor prefix at the start of the string
        x = x.replace('tunnel-wireguard-', '')

        // Add the tunnel name as an option in the select dropdown
        const opt = document.createElement('option')
        opt.value = x
        opt.innerHTML = x
        tunnelSelectElement.appendChild(opt)
      }
    }

    // Show the tunnel options if there are existing tunnels
    if (tunnelSelectElement.childNodes.length > 0) {
      tunnelOptionsElement.classList.remove('invisible')
    }

    // Set the selected tunnel based on local storage
    const selectedTunnel = getSelectedTunnel()
    if (selectedTunnel !== null) {
      setSelectedTunnel(selectedTunnel)
    }

    // Check to see if the WireSock process is already running
    console.log('Checking if WireSock is already running')
    if (await isWiresockRunning()) {
      // WireSock is already running. Update the UI
      tunnelEnabledUI()
    } else {
      tunnelDisabledUI()
    }

    /* ------------------------
    End of code that runs on page load
    ------------------------- */

    /* ------------------------
    Beginning of functions
    ------------------------- */

    // Navigate to the wireguard page
    function addTunnelClick () {
      window.location.href = 'wireguard.html'
    }

    // Navigate to the wireguard page to edit a tunnel
    function editClick () {
      // Name parameter is encoded in case it uses characters not allowed in URL parameters
      // Note there is a bug in Tauri that does not allow URL parameters in the dev server
      // See https://github.com/tauri-apps/tauri/issues/8148 for the issue
      window.location.href = `wireguard.html?edit=true&name=${encodeURIComponent(getSelectedTunnel(), 'UTF-8')}`
    }

    // Save the value of the tunnel select to local storage
    function saveSelectedTunnel () {
      localStorage.setItem('selectedTunnel', tunnelSelectElement.value)
    }

    // Look up local storage for the currenctly selected tunnel
    function getSelectedTunnel () {
      return localStorage.getItem('selectedTunnel')
    }

    // Set the select element to the last selected tunnel
    function setSelectedTunnel () {
      tunnelSelectElement.value = getSelectedTunnel()
    }

    // Tell Rust to enable or disable the WireSock process
    async function toggleTunnel () {
      if (enableButtonElement.innerHTML === 'Enable') {
        // Enable the tunnel

        // Get the currently selected tunnel
        const name = getSelectedTunnel()

        // Get the tunnel data
        const data = JSON.parse(localStorage.getItem(`tunnel-wireguard-${name}`))
        const tunnel = Object.assign(new Tunnel(), data)

        // Send the message down to Tauri Rust function
        try {
          console.info(await invoke('enable_wiresock', {
            // Required parameters
            privateKey: tunnel.privateKey,
            interfaceAddress: tunnel.interfaceAddress,
            dns: tunnel.dns,
            publicKey: tunnel.publicKey,
            endpoint: tunnel.endpoint,
            // Optional parameters
            ...tunnel.presharedKey && { presharedKey: tunnel.presharedKey },
            ...tunnel.allowedApps && { allowedApps: tunnel.allowedApps },
            ...tunnel.disallowedApps && { disallowedApps: tunnel.disallowedApps },
            ...tunnel.allowedIPs && { allowedIPs: tunnel.allowedIPs },
            ...tunnel.disallowedIPs && { disallowedIPs: tunnel.disallowedIPs },
            ...tunnel.mtu && { mtu: tunnel.mtu }
          }))
        } catch (error) {
          console.error(`Invoking enable_wiresock returned error: ${error}`)
          // Show the error to the user
          return showToast(toastElement, toastMessageElement, `${error}`)
        }

        // Connection success so update the UI
        tunnelEnabledUI()
      } else {
        // Disable the tunnel

        try {
          await invoke('disable_wiresock')
        } catch (error) {
          console.error(`Invoking disable_wiresock returned error: ${error}`)
          return showToast(toastElement, toastMessageElement, `Error stopping WireSock process: ${error}`)
        }

        // Update the UI
        tunnelDisabledUI()
      }
    }

    // Set the UI to show the tunnel is enabled
    function tunnelEnabledUI () {
      enableButtonElement.innerHTML = 'Disable'

      tunnelSelectElement.disabled = true

      editButtonElement.disabled = true
    }

    // Set the UI to show the tunnel is disabled
    function tunnelDisabledUI () {
      enableButtonElement.innerHTML = 'Enable'

      tunnelSelectElement.disabled = false

      editButtonElement.disabled = false
    }

    // Tell Rust to check if the WireSock process is running
    async function isWiresockRunning () {
      try {
        const result = await invoke('check_wiresock_process')
        console.info(result)
        if (result === 'WIRESOCK_IS_RUNNING') {
          return true
        } else if (result === 'WIRESOCK_NOT_RUNNING') {
          return false
        } else {
          showToast(toastElement, toastMessageElement, `Error checking WireSock process: ${result}`)
          return false
        }
      } catch (error) {
        console.error(`Invoking check_wiresock_process returned error: ${error}`)
        // Show the error to the user
        return showToast(toastElement, toastMessageElement, error)
      }
    }

    // Tell Rust to check if WireSock is installed
    async function isWiresockInstalled () {
      try {
        const result = await invoke('check_wiresock_installed')
        console.info(result)
        if (result === 'WIRESOCK_INSTALLED') {
          return true
        } else if (result === 'WIRESOCK_NOT_INSTALLED') {
          return false
        } else {
          showToast(toastElement, toastMessageElement, `Error checking if WireSock installed: ${result}`)
          return false
        }
      } catch (error) {
        console.error(`Invoking check_wiresock_installed returned error: ${error}`)
        // Show the error to the user
        return showToast(toastElement, toastMessageElement, error)
      }
    }

    // Tell Rust to check if the WireSock service is installed
    async function isWireSockServiceInstalled () {
      try {
        const result = await invoke('check_wiresock_service')
        console.info(result)
        if (result === 'WIRESOCK_SERVICE_NOT_INSTALLED') {
          return false
        } else if (result === 'WIRESOCK_SERVICE_INSTALLED') {
          return true
        } else {
          showToast(toastElement, toastMessageElement, `Error checking if WireSock service is installed: ${result}`)
          return false
        }
      } catch (error) {
        console.error(`Invoking check_wiresock_service returned error: ${error}`)
        // Show the error to the user
        return showToast(toastElement, toastMessageElement, error)
      }
    }
  </script>
  <link rel="stylesheet" type="text/css" href="./css/globals.css">
</head>

<style>
  select {
    position: relative;
    appearance: auto;
    background-color: #fff;
    border: 1px solid var(--border-color-light);
    border-radius: 0.375rem;
    color: #1a202c;
    font-size: 1rem;
    padding: 0.5rem 2.5rem 0.5rem 0.5rem;
    transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
    font-family: 'HindMadurai', serif;
  }

  select:hover {
    border-color: var(--button-color-light);
  }

  select:focus {
    border-color: var(--button-color-light);
    box-shadow: 0 0 0 3px rgba(4, 102, 200, 0.45);
    outline: none;
  }

  select::-ms-expand {
    display: none;
  }

  select::placeholder {
    color: #a0aec0;
  }
</style>

<!-- body is hidden until light or dark mode is set -->

<body class="hidden">

  <!-- 
    Using async makes the script run immediately as type=module is deferred by default
    This way we can set the dark or light mode before the content is loaded, preventing
    a flash of white before dark mode is set. We only need this on index.html
  -->
  <script type="module" async>
    import { setDarkMode } from './js/globals.js'

    // See if there is a dark mode setting saved in local storage
    if (!localStorage.getItem('darkMode')) {
      const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
      const lightModeMediaQuery = window.matchMedia('(prefers-color-scheme: light)')

      if (darkModeMediaQuery.matches) {
        localStorage.setItem('darkMode', true)
      } else if (lightModeMediaQuery.matches) {
        localStorage.setItem('darkMode', false)
      } else {
        localStorage.setItem('darkMode', false)
      }
    }

    // Set light or dark mode
    setDarkMode()

    // Show the body
    document.body.classList.remove('hidden')
  </script>

  <!----------- Start of HTML content ----------->
  <div class="container">
    <h1 class="container">TunnlTo</h1>
    <div id="tunnelOptions" class="container invisible">
      <select id="tunnelSelect"></select>
      <button id="enableButton">Enable</button>
      <button id="editButton">Edit</button>
    </div>
    <div class="container">
      <button id="addTunnelButton">Add Tunnel</button>
      <a href="settings.html"><button id="settingsButton">Settings</button></a>
    </div>
    <div class="toast" id="toast">
      <p id="toastMessage"><!-- innerHTML is dynamically added in Javascript --></p>
      <button id="toastCloseButton">&#10005;</button>
    </div>
  </div>

</body>
</html>